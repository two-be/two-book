{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":""},{"location":"#remote-copying-with-the-scp-command","title":"Remote Copying With the <code>scp</code> Command","text":"<pre><code>scp [-r] [[user1@]hostname1:]file1 ... [[user2@]hostname2:]file2\n</code></pre> option description <code>-r</code> Use to recursively copy entire directories. <code>user1</code>, <code>user2</code> Login account to use on the remote host. <code>hostname1</code>, <code>hostname2</code> The names of the remote host from or to which the file is to be copied. <code>file1</code> The file name or directory name to be copied. Several source file names may be included on one command line. <code>file2</code> The destination file name or directory name. <p>example <pre><code>scp ./file.ext user:/home/dest\n</code></pre> <pre><code>scp -r ./folder user:/home/dest\n</code></pre></p>"},{"location":"ASP.NET%20Framework/","title":"ASP.NET Framework","text":"","tags":["ASP.NET Framework","dotnet"]},{"location":"ASP.NET%20Framework/#json-camelcase","title":"JSON camelCase","text":"<pre><code>public static class WebApiConfig\n{\npublic static void Register(HttpConfiguration config)\n{\n// ..\nconfig.Formatters.JsonFormatter.SerializerSettings = new JsonSerializerSettings\n{\nContractResolver = new CamelCasePropertyNamesContractResolver(),\n// Formatting = Formatting.Indented,\n// ReferenceLoopHandling = ReferenceLoopHandling.Ignore,\n};\n// ..\n}\n}\n</code></pre>","tags":["ASP.NET Framework","dotnet"]},{"location":"ASP.NET%20Framework/#return-json-instead-of-xml","title":"Return JSON Instead of XML","text":"<pre><code>public static class WebApiConfig\n{\npublic static void Register(HttpConfiguration config)\n{\n// ..\nconfig.Formatters.JsonFormatter.SupportedMediaTypes.Add(new MediaTypeHeaderValue(\"text/html\"));\n// ..\n}\n}\n</code></pre>","tags":["ASP.NET Framework","dotnet"]},{"location":"Docker/","title":"Docker","text":"","tags":["Docker"]},{"location":"Docker/#depends_on","title":"depends_on","text":"<pre><code>  depends_on:\n- \"db\"\n</code></pre>","tags":["Docker"]},{"location":"Docker/#start-containers-automatically","title":"Start containers automatically","text":"<pre><code>  restart: \"always\"\n</code></pre>","tags":["Docker"]},{"location":"Docker/#timezone","title":"timezone","text":"<pre><code>  environment:\nTZ: \"Asia/Bangkok\"\n</code></pre>","tags":["Docker"]},{"location":"Docker/#docker-composeyml","title":"docker-compose.yml","text":"ASP.NETCaddyMicrosoft SQL ServerPostgreSQL <pre><code>version: \"x.x\"\nservices:\napp:\nimage: \"aspnetapp\"\nvolumes:\n- \"./appsettings.json:/app/appsettings.json\"\n</code></pre> <p>Dockerfile <pre><code>FROM mcr.microsoft.com/dotnet/aspnet:x.x\nWORKDIR /app\nCOPY  /published ./\nENTRYPOINT [\"dotnet\", \"aspnetapp.dll\"]\n</code></pre></p> <pre><code>version: \"x.x\"\nservices:\ncaddy:\nimage: \"caddy\"\nports:\n- \"80:80\"\n- \"443:443\"\nvolumes:\n- \"./Caddyfile:/etc/caddy/Caddyfile\"\n- \"caddy_data:/data\"\nvolumes:\ncaddy_data:\n</code></pre> <p>Caddyfile <pre><code>localhost {\n    reverse_proxy 127.0.0.1:9005\n}\n</code></pre></p> <pre><code>version: \"x.x\"\nservices:\nmssql:\nimage: \"mcr.microsoft.com/mssql/server:2022-latest\"\nenvironment:\nACCEPT_EULA: \"Y\"\n# MSSQL_PID: \"Express\"\nSA_PASSWORD: \"password\"\nports:\n- \"1433:1433\"\nvolumes:\n- \"./mssql/data:/var/opt/mssql/data\"\n- \"./mssql/log:/var/opt/mssql/log\"\n- \"./mssql/secrets:/var/opt/mssql/secrets\"\n</code></pre> <pre><code>version: \"x.x\"\nservices:\npostgres:\nimage: \"postgres\"\nenvironment:\nPOSTGRES_PASSWORD: \"password\"\nPOSTGRES_USER: \"postgres\"\nports:\n- \"5432:5432\"\nvolumes:\n- \"./postgresql/data:/var/lib/postgresql/data\"\n</code></pre>","tags":["Docker"]},{"location":"GitHub%20Actions/","title":"GitHub Actions","text":"","tags":["CI/CD","GitHub Actions"]},{"location":"GitHub%20Actions/#net","title":".NET","text":"<pre><code>name: main\non:\npush:\ntags:\n- \"*\"\njobs:\nbuild:\nruns-on: ubuntu-latest\nsteps:\n- uses: actions/checkout@v2\n- name: Setup .NET\nuses: actions/setup-dotnet@v1\nwith:\ndotnet-version: 6.0.x\n- name: .NET - Restore dependencies\nrun: dotnet restore src/AspNetApp/AspNetApp.csproj\n- name: .NET - Build\nrun: dotnet build --no-restore src/AspNetApp/AspNetApp.csproj\n- name: .NET - Publish\nrun: dotnet publish src/AspNetApp/AspNetApp.csproj -c Release -o published\n</code></pre>","tags":["CI/CD","GitHub Actions"]},{"location":"GitHub%20Actions/#angular","title":"Angular","text":"<pre><code>name: main\non:\npush:\ntags:\n- \"*\"\njobs:\nbuild:\nruns-on: ubuntu-latest\nsteps:\n- uses: actions/checkout@v2\n- name: Use Node.js\nuses: actions/setup-node@v1\nwith:\nnode-version: 15.x\n- name: Angular - npm install\nrun: |\ncd src/angular-app\nnpm install\n- name: Angular - npm run build\nrun: |\ncd src/angular-app\nnpm run build\n</code></pre>","tags":["CI/CD","GitHub Actions"]},{"location":"GitHub%20Actions/#docker","title":"Docker","text":"<pre><code>name: main\non:\npush:\ntags:\n- \"*\"\nenv:\nIMAGE_NAME: ${{ github.repository }}\nREGISTRY: ghcr.io\njobs:\nbuild:\nruns-on: ubuntu-latest\nsteps:\n- uses: actions/checkout@v2\n- name: Log into registry ${{ env.REGISTRY }}\nuses: docker/login-action@28218f9b04b4f3f62068d7b6ce6ca5b26e35336c\nwith:\nregistry: ${{ env.REGISTRY }}\nusername: ${{ github.actor }}\npassword: ${{ secrets.GITHUB_TOKEN }}\n- name: Extract Docker metadata\nid: meta\nuses: docker/metadata-action@98669ae865ea3cffbcbaa878cf57c20bbf1c6c38\nwith:\nimages: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n- name: Build and push Docker image\nuses: docker/build-push-action@ad44023a93711e3deb337508980b4b5e9bcdc5dc\nwith:\ncontext: .\npush: true\ntags: ${{ steps.meta.outputs.tags }}\nlabels: ${{ steps.meta.outputs.labels }}\n</code></pre>","tags":["CI/CD","GitHub Actions"]},{"location":"JavaScript/","title":"JavaScript","text":"","tags":["JavaScript"]},{"location":"JavaScript/#flatten-an-array-of-arrays","title":"Flatten an array of arrays","text":"<pre><code>let flattened = [[0, 1], [2, 3], [4]].reduce((x, y) =&gt; x.concat(y))\n// flattened is [0, 1, 2, 3, 4]\n</code></pre>","tags":["JavaScript"]},{"location":"JavaScript/#locale-date-string","title":"Locale Date String","text":"<pre><code>let date = new Date(2020, 1, 29)\ndate.toLocaleDateString(\"th-TH\", {\nyear: \"numeric\",\nmonth: \"long\",\nday: \"numeric\"\n})\n// 29 \u0e01\u0e38\u0e21\u0e20\u0e32\u0e1e\u0e31\u0e19\u0e18\u0e4c 2563\n</code></pre>","tags":["JavaScript"]},{"location":"JavaScript/#sort-an-array-of-dates","title":"Sort an array of dates","text":"<pre><code>let dates = [\nnew Date(2022, 1, 2),\nnew Date(2022, 0, 2),\n];\ndates.sort((x, y) =&gt; x - y)\n// [Sun Jan 02 2022 00:00:00 GMT+0700 (Indochina Time), Wed Feb 02 2022 00:00:00 GMT+0700 (Indochina Time) ]\n</code></pre>","tags":["JavaScript"]},{"location":"JavaScript/#suffle-an-array","title":"Suffle an array","text":"<pre><code>let shuffled = [0, 1, 2, 3, 4].sort(() =&gt; 0.5 - Math.random())\n// shuffled may be [2, 3, 4, 1, 0]\n</code></pre>","tags":["JavaScript"]},{"location":"PostgreSQL/","title":"PostgreSQL","text":"","tags":["PostgreSQL"]},{"location":"PostgreSQL/#starting-a-sequence-at-maxcolumn-1","title":"Starting a sequence at MAX(column) + 1","text":"<pre><code>SELECT SETVAL('public.\"table_Id_seq\"', COALESCE(MAX(\"Id\"), 1)) FROM public.\"table\";\n</code></pre>","tags":["PostgreSQL"]},{"location":"TypeScript/","title":"TypeScript","text":"","tags":["TypeScript"]},{"location":"TypeScript/#template-literal-types","title":"Template Literal Types","text":"<pre><code>type World = \"world\";\ntype Greeting = `hello ${World}`;\n// type Greeting = \"hello world\"\n</code></pre> <pre><code>type EmailLocaleIDs = \"welcome_email\" | \"email_heading\";\ntype FooterLocaleIDs = \"footer_title\" | \"footer_sendoff\";\ntype AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;\n// type AllLocaleIDs = \"welcome_email_id\" | \"email_heading_id\" | \"footer_title_id\" | \"footer_sendoff_id\"\n</code></pre> <pre><code>type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;\ntype Lang = \"en\" | \"ja\" | \"pt\";\ntype LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;\n// type LocaleMessageIDs = \"en_welcome_email_id\" | \"en_email_heading_id\" | \"en_footer_title_id\" | \"en_footer_sendoff_id\" | \"ja_welcome_email_id\" | \"ja_email_heading_id\" | \"ja_footer_title_id\" | \"ja_footer_sendoff_id\" | \"pt_welcome_email_id\" | \"pt_email_heading_id\" | \"pt_footer_title_id\" | \"pt_footer_sendoff_id\"\n</code></pre> <pre><code>type Greeting = \"Hello, world\"\ntype ShoutyGreeting = Uppercase&lt;Greeting&gt; //Capitalize&lt;LowercaseGreeting&gt; | Uncapitalize&lt;UppercaseGreeting&gt;\n// type ShoutyGreeting = \"HELLO, WORLD\"\n</code></pre> <pre><code>type ASCIICacheKey&lt;Str extends string&gt; = `id-${Lowercase&lt;Str&gt;}`\ntype MainID = ASCIICacheKey&lt;\"MY_APP\"&gt;\n// type MainID = \"id-my_app\"\n</code></pre>","tags":["TypeScript"]},{"location":"C%23/","title":"Index","text":"","tags":["C#","csharp"]},{"location":"C%23/#check-a-string-property-for-null","title":"Check a string property for null","text":"<pre><code>var user = new UserInfo();\nConsole.WriteLine(user.Username is { }); // false\nConsole.WriteLine(string.IsNullOrWhiteSpace(user.Username)); // true\nConsole.WriteLine(user.Username is { Length: &gt; 0 }); // false\nConsole.WriteLine(user.Username is not null); // false\n</code></pre>","tags":["C#","csharp"]},{"location":"C%23/#sha512","title":"SHA512","text":"<pre><code>using var sha = System.Security.Cryptography.SHA512.Create();\nvar utf8Bytes = Encoding.UTF8.GetBytes(value);\nvar hash = sha.ComputeHash(utf8Bytes);\nvar value = BitConverter.ToString(hash).Replace(\"-\", string.Empty);\n</code></pre>","tags":["C#","csharp"]},{"location":"C%23/1.0/","title":"1.0","text":"<p>C# 1.0, released in 2002 as part of Microsoft's .NET initiative, introduced a wide range of features designed to combine the power and flexibility of C++ with the simplicity of Visual Basic. Here are some of the key features of C# 1.0 along with examples for each:</p>","tags":["C#","csharp"]},{"location":"C%23/1.0/#1-strong-typing","title":"1. Strong Typing","text":"<p>C# is a strongly-typed language, meaning that every variable and object instance must have a declared type.</p> <pre><code>int number = 5;  // 'number' is explicitly defined as an integer\n</code></pre>","tags":["C#","csharp"]},{"location":"C%23/1.0/#2-object-oriented","title":"2. Object-Oriented","text":"<p>Everything in C# is associated with classes and objects, along with their attributes and methods.</p> <pre><code>class Person {\npublic string Name { get; set; }\npublic void Introduce() {\nConsole.WriteLine($\"Hi, my name is {Name}\");\n}\n}\nPerson person = new Person();\nperson.Name = \"John\";\nperson.Introduce();  // Output: \"Hi, my name is John\"\n</code></pre>","tags":["C#","csharp"]},{"location":"C%23/1.0/#3-automatic-memory-management","title":"3. Automatic Memory Management","text":"<p>C# uses garbage collection to automatically manage memory, eliminating the need to manually release memory.</p> <pre><code>// Memory allocation\nPerson person = new Person();\n// Memory is automatically reclaimed by the garbage collector when 'person' is no longer in use.\n</code></pre>","tags":["C#","csharp"]},{"location":"C%23/1.0/#4-properties","title":"4. Properties","text":"<p>Properties provide a flexible mechanism to read, write, or compute the values of private fields.</p> <pre><code>class Person {\nprivate string name;\npublic string Name {\nget { return name; }\nset { name = value; }\n}\n}\n</code></pre>","tags":["C#","csharp"]},{"location":"C%23/1.0/#5-events-and-delegates","title":"5. Events and Delegates","text":"<p>C# supports events and delegates, enabling a way to provide event handling.</p> <pre><code>public delegate void EventHandler(string message);\nclass EventDemo {\npublic event EventHandler OnChange;\npublic void Change(string message) {\nif (OnChange != null) {\nOnChange(message);\n}\n}\n}\nEventDemo demo = new EventDemo();\ndemo.OnChange += (message) =&gt; Console.WriteLine(message);\ndemo.Change(\"Event triggered\");  // Output: \"Event triggered\"\n</code></pre>","tags":["C#","csharp"]},{"location":"C%23/1.0/#6-versioning","title":"6. Versioning","text":"<p>C# includes features such as assemblies and strong names to provide versioning control.</p> <pre><code>// Assemblies can be given strong names to ensure that applications reference the correct version of a library.\n</code></pre>","tags":["C#","csharp"]},{"location":"C%23/1.0/#7-error-handling-with-exceptions","title":"7. Error Handling with Exceptions","text":"<p>C# uses structured exception handling, based on try, catch, and finally blocks.</p> <pre><code>try {\n// Code that might throw an exception\nint[] numbers = {1, 2, 3};\nConsole.WriteLine(numbers[3]);  // This will throw an IndexOutOfRangeException\n} catch (IndexOutOfRangeException e) {\nConsole.WriteLine(\"An exception occurred: \" + e.Message);\n} finally {\n// Code to execute after try/catch, regardless of an exception\nConsole.WriteLine(\"Finally block executed\");\n}\n</code></pre>","tags":["C#","csharp"]},{"location":"C%23/1.0/#8-array","title":"8. Array","text":"<p>Arrays are used to store multiple values in a single variable.</p> <pre><code>int[] numbers = new int[5] {1, 2, 3, 4, 5};  // Declaring and initializing an array\nConsole.WriteLine(numbers[0]);  // Accessing the first element of the array\n</code></pre>","tags":["C#","csharp"]},{"location":"C%23/10.0/","title":"10.0","text":"<p>C# 10.0, released with .NET 6 in November 2021, introduced several features and improvements aimed at simplifying code, enhancing the clarity of programs, and reducing boilerplate code. Here are some of the key features introduced in C# 10.0, along with examples and comparisons to earlier versions of C#:</p>","tags":["C#","csharp"]},{"location":"C%23/10.0/#1-global-using-directives","title":"1. Global Using Directives","text":"<p>C# 10.0 introduced global using directives, allowing you to specify using directives that are applied globally across all source files in a project, reducing the need to include common using directives in every file.</p> <p>C# 10.0 In a GlobalUsings.cs file: <pre><code>global using System;\nglobal using System.Collections.Generic;\n</code></pre> These using directives do not need to be repeated in other source files.</p> <p>C# &lt; 10.0 Previously, you had to include common using directives in every source file, which could lead to repetitive boilerplate code at the top of each file. <pre><code>using System;\nusing System.Collections.Generic;\n// This needed to be repeated in each source file.\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/10.0/#2-file-scoped-namespaces","title":"2. File-scoped Namespaces","text":"<p>C# 10.0 allows for file-scoped namespaces, reducing the indentation level for the entire file and making the code more concise.</p> <p>C# 10.0 <pre><code>namespace MyApplication;\nclass MyClass\n{\n// Class implementation\n}\n</code></pre></p> <p>C# &lt; 10.0 In earlier versions, namespaces required braces, which introduced an additional level of indentation. <pre><code>namespace MyApplication\n{\nclass MyClass\n{\n// Class implementation\n}\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/10.0/#3-record-structs","title":"3. Record Structs","text":"<p>C# 10.0 introduced record structs, expanding the record types introduced in C# 9.0 to struct types, providing value semantics for immutable data models.</p> <p>C# 10.0 <pre><code>public record struct Point(double X, double Y);\n</code></pre></p> <p>C# &lt; 10.0 Before C# 10.0, records were limited to reference types, and creating immutable value types required more boilerplate code. <pre><code>public struct Point\n{\npublic double X { get; init; }\npublic double Y { get; init; }\npublic Point(double x, double y) =&gt; (X, Y) = (x, y);\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/10.0/#4-improved-interpolated-strings","title":"4. Improved Interpolated Strings","text":"<p>C# 10.0 improved the performance and usability of interpolated strings by allowing them to be used as constants, parameters for attributes, and in more contexts where string literals are permitted.</p> <p>C# 10.0 <pre><code>const string Name = \"World\";\nconst string Greeting = $\"Hello, {Name}!\";\n</code></pre></p> <p>C# &lt; 10.0 Previously, interpolated strings could not be used in contexts that required constant expressions. <pre><code>const string Name = \"World\";\n// The following was not possible; had to use string concatenation or similar\n// const string Greeting = $\"Hello, {Name}!\";\nconst string Greeting = \"Hello, \" + Name + \"!\";\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/10.0/#5-lambda-improvements","title":"5. Lambda Improvements","text":"<p>C# 10.0 introduced several improvements to lambda expressions, including natural type inference, making it easier to work with lambda expressions in generic contexts.</p> <p>C# 10.0 <pre><code>var numbers = new List&lt;int&gt; { 1, 2, 3, 4 };\nvar doubledNumbers = numbers.Select(static number =&gt; number * 2);\n</code></pre></p> <p>C# &lt; 10.0 In previous versions, it was sometimes necessary to explicitly specify the lambda parameter type, especially in generic contexts. <pre><code>var numbers = new List&lt;int&gt; { 1, 2, 3, 4 };\nvar doubledNumbers = numbers.Select((int number) =&gt; number * 2);\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/11.0/","title":"11.0","text":"<p>C# 11.0, which is part of the .NET 7 release in November 2022, introduced several new features and enhancements that further improve the language's expressiveness, safety, and performance. Here are some of the key features introduced in C# 11.0, along with examples and comparisons to earlier versions of C#:</p>","tags":["C#","csharp"]},{"location":"C%23/11.0/#1-list-patterns","title":"1. List Patterns","text":"<p>List patterns allow for concise syntax when working with lists or arrays, enabling pattern matching based on the contents of a collection.</p> <p>C# 11.0 <pre><code>int[] numbers = { 1, 2, 3, 4, 5 };\nif (numbers is [1, 2, .., 5])\n{\nConsole.WriteLine(\"Starts with 1, 2 and ends with 5\");\n}\n</code></pre></p> <p>C# &lt; 11.0 Previously, achieving similar functionality required manual checking of individual elements and the collection's length, which was more verbose and error-prone. <pre><code>int[] numbers = { 1, 2, 3, 4, 5 };\nif (numbers.Length &gt;= 3 &amp;&amp; numbers[0] == 1 &amp;&amp; numbers[1] == 2 &amp;&amp; numbers[^1] == 5)\n{\nConsole.WriteLine(\"Starts with 1, 2 and ends with 5\");\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/11.0/#2-required-members","title":"2. Required Members","text":"<p>C# 11.0 introduces the concept of required members, allowing you to specify that certain properties or fields must be initialized when an object is created, enhancing object initialization safety.</p> <p>C# 11.0 <pre><code>public class Person\n{\npublic required string Name { get; set; }\n}\nvar person = new Person { Name = \"Alice\" }; // Compiles fine\n// var person = new Person(); // Error: The required property 'Name' must be initialized\n</code></pre></p> <p>C# &lt; 11.0 Before C# 11.0, ensuring that properties were initialized required custom validation logic, possibly in the constructor or via a factory method. <pre><code>public class Person\n{\npublic string Name { get; set; }\npublic Person(string name)\n{\nName = name ?? throw new ArgumentNullException(nameof(name));\n}\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/11.0/#3-raw-string-literals","title":"3. Raw String Literals","text":"<p>Raw string literals simplify the declaration of strings that contain newlines, quotes, and other special characters without the need for escape sequences, making it easier to work with JSON, XML, or HTML snippets.</p> <p>C# 11.0 <pre><code>string json = \"\"\"\n{\n\"name\": \"Alice\",\n\"age\": 30\n}\n\"\"\";\n</code></pre></p> <p>C# &lt; 11.0 Previously, working with multi-line strings or strings with special characters required escape sequences, which could make the string hard to read and maintain. <pre><code>string json = \"{\\n    \\\"name\\\": \\\"Alice\\\",\\n    \\\"age\\\": 30\\n}\";\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/11.0/#4-enhanced-generic-math","title":"4. Enhanced Generic Math","text":"<p>C# 11.0 provides improved support for generic math, making it easier to write generic algorithms that work with any numeric type, building upon the <code>System.Numerics</code> namespace enhancements.</p> <p>C# 11.0 <pre><code>public static T Add&lt;T&gt;(T a, T b) where T : INumber&lt;T&gt;\n{\nreturn a + b;\n}\n</code></pre></p> <p>C# &lt; 11.0 Before C# 11.0, writing generic mathematical operations required constraints to interfaces like <code>IComparable</code>, <code>IFormattable</code>, etc., or custom interfaces, and often involved runtime checks and casting, which was less efficient and more cumbersome. <pre><code>public static T Add&lt;T&gt;(T a, T b) where T : IComparable, IFormattable\n{\ndynamic x = a, y = b;\nreturn x + y;\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/11.0/#5-static-abstract-members-in-interfaces","title":"5. Static Abstract Members in Interfaces","text":"<p>C# 11.0 allows abstract static members in interfaces, enabling polymorphic behavior on static members. This feature is particularly useful in combination with generic math.</p> <p>C# 11.0 <pre><code>interface IAddition&lt;T&gt;\n{\nstatic abstract T Add(T a, T b);\n}\nclass IntegerAddition : IAddition&lt;int&gt;\n{\npublic static int Add(int a, int b) =&gt; a + b;\n}\n</code></pre></p> <p>C# &lt; 11.0 Previously, interfaces could not contain static members, limiting the design of certain types of generic programming patterns and requiring alternative approaches, such as using abstract classes or pattern-based designs.</p>","tags":["C#","csharp"]},{"location":"C%23/2.0/","title":"2.0","text":"<p>C# 2.0, released with .NET Framework 2.0 in November 2005, introduced several new features and enhancements over C# 1.0. These features aimed to improve the productivity of developers, provide more powerful programming constructs, and make the language more flexible and expressive. Here are some of the key features introduced in C# 2.0, along with examples and comparisons to C# 1.0:</p>","tags":["C#","csharp"]},{"location":"C%23/2.0/#1-generics","title":"1. Generics","text":"<p>Generics allow the definition of classes, interfaces, and methods with a placeholder for the type they operate on. This results in stronger type safety and performance improvements over using the <code>System.Object</code> type for collections.</p> <p>C# 2.0 <pre><code>List&lt;int&gt; numbers = new List&lt;int&gt;();\nnumbers.Add(1);  // Strongly-typed, no boxing/unboxing\n</code></pre></p> <p>C# &lt; 2.0 In C# 1.0, collections stored <code>object</code> types, requiring casting and boxing/unboxing for value types, which was less efficient and more error-prone. <pre><code>ArrayList numbers = new ArrayList();\nnumbers.Add(1);  // Object type, requires boxing for value types\nint firstNumber = (int)numbers[0];  // Requires explicit cast\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/2.0/#2-partial-classes","title":"2. Partial Classes","text":"<p>Partial classes allow the code for a single class to be split into multiple files. This is particularly useful for separating generated code from developer-written code.</p> <p>C# 2.0 <pre><code>// File1.cs\npublic partial class MyClass {\npublic void Method1() { }\n}\n// File2.cs\npublic partial class MyClass {\npublic void Method2() { }\n}\n</code></pre></p> <p>C# &lt; 2.0 In C# 1.0, all code for a class had to be contained within a single file, which could become unwieldy for large classes or when part of the class code was auto-generated (e.g., by designer tools).</p>","tags":["C#","csharp"]},{"location":"C%23/2.0/#3-anonymous-methods","title":"3. Anonymous Methods","text":"<p>Anonymous methods provide a way to define inline unnamed methods, useful for event handlers and delegate instantiation without the need to explicitly define a separate method.</p> <p>C# 2.0 <pre><code>List&lt;int&gt; numbers = new List&lt;int&gt; { 1, 2, 3 };\nnumbers.ForEach(delegate(int number) {\nConsole.WriteLine(number);\n});\n</code></pre></p> <p>C# &lt; 2.0 In C# 1.0, you had to explicitly define a method, even for simple delegate invocations, making the code more verbose. <pre><code>public void PrintNumber(int number) {\nConsole.WriteLine(number);\n}\n// Usage with a delegate\nnumbers.ForEach(new Action&lt;int&gt;(PrintNumber));\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/2.0/#4-iterators","title":"4. Iterators","text":"<p>Iterators simplify the implementation of <code>IEnumerable</code> and <code>IEnumerator</code> patterns using the <code>yield return</code> and <code>yield break</code> statements, making it easier to create custom collection classes.</p> <p>C# 2.0 <pre><code>public IEnumerable&lt;int&gt; GetNumbers() {\nfor (int i = 0; i &lt; 10; i++) {\nyield return i;\n}\n}\n</code></pre></p> <p>C# &lt; 2.0 In C# 1.0, implementing custom iterators required manually managing the state machine, which was cumbersome and error-prone. <pre><code>public class NumberEnumerable : IEnumerable {\npublic IEnumerator GetEnumerator() {\nreturn new NumberEnumerator();\n}\n}\npublic class NumberEnumerator : IEnumerator {\nprivate int count = -1;\npublic bool MoveNext() {\ncount++;\nreturn count &lt; 10;\n}\npublic object Current {\nget { return count; }\n}\n// Reset method implementation\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/2.0/#5-nullable-types","title":"5. Nullable Types","text":"<p>Nullable types allow value types to represent all the values of an underlying type plus an additional null value, which is particularly useful for database interactions and other scenarios where value types need to represent the absence of a value.</p> <p>C# 2.0 <pre><code>int? nullableInt = null;\nif (nullableInt.HasValue) {\nConsole.WriteLine(nullableInt.Value);\n} else {\nConsole.WriteLine(\"null\");\n}\n</code></pre></p> <p>C# &lt; 2.0 In C# 1.0, there was no built-in support for nullable value types. Developers had to use workarounds, such as special value assignments (e.g., using <code>-1</code> or <code>int.MaxValue</code> to represent an undefined or null integer) or use reference types, which was less efficient.</p>","tags":["C#","csharp"]},{"location":"C%23/3.0/","title":"3.0","text":"<p>C# 3.0, released with .NET Framework 3.5 in November 2007, introduced a number of significant features that built upon the capabilities of C# 2.0, enhancing the language's expressiveness, readability, and efficiency, particularly in data manipulation and querying. Here's a look at some of the key features introduced in C# 3.0, with examples and comparisons to earlier versions:</p>","tags":["C#","csharp"]},{"location":"C%23/3.0/#1-auto-implemented-properties","title":"1. Auto-Implemented Properties","text":"<p>C# 3.0 introduced auto-implemented properties, simplifying property declaration when no additional logic is required in the property accessors.</p> <p>C# 3.0 <pre><code>public class Person {\npublic string Name { get; set; }\n}\n</code></pre></p> <p>C# &lt; 3.0 In earlier versions, you had to define backing fields and explicitly implement the property get and set accessors. <pre><code>public class Person {\nprivate string name;\npublic string Name {\nget { return name; }\nset { name = value; }\n}\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/3.0/#2-implicitly-typed-local-variables-var","title":"2. Implicitly Typed Local Variables (var)","text":"<p>The <code>var</code> keyword allows the compiler to infer the type of a local variable, making the code cleaner, especially when dealing with complex types.</p> <p>C# 3.0 <pre><code>var numbers = new List&lt;int&gt;();  // The compiler infers that 'numbers' is a List&lt;int&gt;\n</code></pre></p> <p>C# &lt; 3.0 Previously, you had to explicitly specify the type of the local variable. <pre><code>List&lt;int&gt; numbers = new List&lt;int&gt;();\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/3.0/#3-object-and-collection-initializers","title":"3. Object and Collection Initializers","text":"<p>Object and collection initializers allow you to create and initialize objects and collections in a more concise and readable way.</p> <p>C# 3.0 <pre><code>var person = new Person { Name = \"Alice\" };\nvar numbers = new List&lt;int&gt; { 1, 2, 3 };\n</code></pre></p> <p>C# &lt; 3.0 Before C# 3.0, you had to create the object or collection and then set properties or add items in separate statements. <pre><code>Person person = new Person();\nperson.Name = \"Alice\";\nList&lt;int&gt; numbers = new List&lt;int&gt;();\nnumbers.Add(1);\nnumbers.Add(2);\nnumbers.Add(3);\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/3.0/#4-anonymous-types","title":"4. Anonymous Types","text":"<p>Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.</p> <p>C# 3.0 <pre><code>var product = new { Name = \"Laptop\", Price = 1200 };\nConsole.WriteLine(product.Name);  // Output: Laptop\n</code></pre></p> <p>C# &lt; 3.0 Previously, to achieve similar functionality, you had to define a class or struct. <pre><code>public class Product {\npublic string Name { get; set; }\npublic int Price { get; set; }\n}\nProduct product = new Product { Name = \"Laptop\", Price = 1200 };\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/3.0/#5-extension-methods","title":"5. Extension Methods","text":"<p>Extension methods allow you to add new methods to existing types without modifying the original type, enhancing the usability of existing classes or interfaces.</p> <p>C# 3.0 <pre><code>public static class StringExtensions {\npublic static int WordCount(this string str) {\nreturn str.Split(new char[] { ' ', '.', '?' }, StringSplitOptions.RemoveEmptyEntries).Length;\n}\n}\nstring text = \"Hello, world!\";\nConsole.WriteLine(text.WordCount());  // Output: 2\n</code></pre></p> <p>C# &lt; 3.0 Before extension methods, you typically had to create a utility class with static methods to achieve similar functionality. <pre><code>public static class StringUtils {\npublic static int WordCount(string str) {\nreturn str.Split(new char[] { ' ', '.', '?' }, StringSplitOptions.RemoveEmptyEntries).Length;\n}\n}\nstring text = \"Hello, world!\";\nConsole.WriteLine(StringUtils.WordCount(text));\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/3.0/#6-language-integrated-query-linq","title":"6. Language Integrated Query (LINQ)","text":"<p>LINQ introduces query capabilities directly in C# syntax, allowing for more expressive and readable data querying and manipulation.</p> <p>C# 3.0 <pre><code>var numbers = new List&lt;int&gt; { 1, 2, 3, 4, 5 };\nvar evenNumbers = from n in numbers\nwhere n % 2 == 0\nselect n;\nforeach (var n in evenNumbers) {\nConsole.WriteLine(n);  // Output: 2 4\n}\n</code></pre></p> <p>C# &lt; 3.0 Prior to LINQ, querying and manipulating collections or data sources required more verbose and less intuitive code, often involving loops and conditional statements.</p> <pre><code>List&lt;int&gt; evenNumbers = new List&lt;int&gt;();\nforeach (int n in numbers) {\nif (n % 2 == 0) {\nevenNumbers.Add(n);\n}\n}\nforeach (int n in evenNumbers) {\nConsole.WriteLine(n);  // Output: 2 4\n}\n</code></pre>","tags":["C#","csharp"]},{"location":"C%23/4.0/","title":"4.0","text":"<p>C# 4.0, released with .NET Framework 4 in April 2010, introduced several new features aimed at improving interoperation with dynamic languages and COM APIs, and making the language more flexible. Here are some of the key features introduced in C# 4.0, along with examples and comparisons to earlier versions of C#:</p>","tags":["C#","csharp"]},{"location":"C%23/4.0/#1-dynamic-binding","title":"1. Dynamic Binding","text":"<p>The <code>dynamic</code> keyword was introduced to bypass static type checking. This is particularly useful when interacting with COM objects, dynamic languages, or reflection, where types might not be known at compile time.</p> <p>C# 4.0 <pre><code>dynamic dynamicObject = 4;\ndynamicObject = \"Hello, world!\";  // No compile-time type checking\nConsole.WriteLine(dynamicObject);  // Output: Hello, world!\n</code></pre></p> <p>C# &lt; 4.0 In earlier versions of C#, you had to use <code>object</code> and often needed explicit casting or reflection to work with types that could change at runtime, which was less convenient and more error-prone. <pre><code>object obj = 4;\nobj = \"Hello, world!\";\nConsole.WriteLine((string)obj);  // Requires explicit cast\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/4.0/#2-named-and-optional-arguments","title":"2. Named and Optional Arguments","text":"<p>Named and optional arguments make method calls more flexible and readable by allowing arguments to be specified by name and by omitting optional arguments.</p> <p>C# 4.0 <pre><code>public void SendMessage(string to, string subject, string body, bool ccAdmin = false) { }\n// Using named and optional arguments\nSendMessage(subject: \"Hello\", body: \"World\", to: \"example@example.com\");\n</code></pre></p> <p>C# &lt; 4.0 Previously, you had to provide all arguments in the exact order they were defined in the method signature, and use method overloads to achieve similar functionality. <pre><code>public void SendMessage(string to, string subject, string body) { }\npublic void SendMessageWithCC(string to, string subject, string body, bool ccAdmin) { }\n// Without named and optional arguments\nSendMessage(\"example@example.com\", \"Hello\", \"World\");\nSendMessageWithCC(\"example@example.com\", \"Hello\", \"World\", false);\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/4.0/#3-generic-covariance-and-contravariance","title":"3. Generic Covariance and Contravariance","text":"<p>Support for covariance and contravariance in generic interfaces and delegates makes it easier to work with types in a type-safe manner, especially when dealing with inheritance hierarchies.</p> <p>C# 4.0 <pre><code>IEnumerable&lt;string&gt; strings = new List&lt;string&gt;();\nIEnumerable&lt;object&gt; objects = strings;  // Covariance: IEnumerable&lt;T&gt; is covariant\n</code></pre></p> <p>C# &lt; 4.0 In earlier versions, you could not assign an instance of a generic collection of a derived type to a generic collection of a base type without explicit casting or conversion, even if it was logically safe to do so. <pre><code>List&lt;string&gt; strings = new List&lt;string&gt;();\n// Not allowed in C# 3.0 and earlier: List&lt;object&gt; objects = strings;\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/4.0/#4-com-interop-improvements","title":"4. COM Interop Improvements","text":"<p>C# 4.0 introduced improvements to COM interop, such as the ability to omit ref modifiers on COM method calls, making it easier to work with COM objects.</p> <p>C# 4.0 <pre><code>// Assume 'comObject' is a COM object with a method 'MethodTakingRefParameter(ref int)'\ndynamic comObject = GetComObject();\nint value = 10;\ncomObject.MethodTakingRefParameter(value);  // 'ref' not needed\n</code></pre></p> <p>C# &lt; 4.0 In earlier versions, working with COM objects required more boilerplate code, including the use of <code>ref</code> and <code>out</code> modifiers when calling methods with reference parameters. <pre><code>// Using early binding and COM interop in C# 3.0\nint value = 10;\ncomObject.MethodTakingRefParameter(ref value);  // 'ref' needed\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/5.0/","title":"5.0","text":"<p>C# 5.0, released with .NET Framework 4.5 in August 2012, focused primarily on asynchronous programming and improving the performance of applications that perform I/O-bound or CPU-bound operations. Here are the key features introduced in C# 5.0, along with examples and comparisons to earlier versions of C#:</p>","tags":["C#","csharp"]},{"location":"C%23/5.0/#1-asyncawait","title":"1. Async/Await","text":"<p>The <code>async</code> and <code>await</code> keywords were introduced to simplify writing asynchronous code, making it more readable and maintainable by avoiding callback \"pyramids of doom\" and making asynchronous code appear more like its synchronous counterpart.</p> <p>C# 5.0 <pre><code>public async Task&lt;string&gt; GetWebPageAsync(string url)\n{\nusing (HttpClient client = new HttpClient())\n{\nstring content = await client.GetStringAsync(url);\nreturn content;\n}\n}\n</code></pre> This method asynchronously downloads the content of a web page, and the <code>await</code> keyword is used to await the completion of the asynchronous operation without blocking the calling thread.</p> <p>C# &lt; 5.0 Before C# 5.0, asynchronous programming involved more complex patterns, such as the use of callbacks, the <code>IAsyncResult</code> pattern, or the Event-based Asynchronous Pattern (EAP). <pre><code>public void GetWebPage(string url, Action&lt;string&gt; callback)\n{\nWebClient client = new WebClient();\nclient.DownloadStringCompleted += (sender, e) =&gt;\n{\nif (e.Error == null)\n{\ncallback(e.Result);\n}\n};\nclient.DownloadStringAsync(new Uri(url));\n}\n</code></pre> This approach is more cumbersome and harder to read, especially when dealing with multiple asynchronous operations.</p>","tags":["C#","csharp"]},{"location":"C%23/5.0/#2-caller-information-attributes","title":"2. Caller Information Attributes","text":"<p>C# 5.0 introduced Caller Information attributes (<code>CallerFilePath</code>, <code>CallerLineNumber</code>, <code>CallerMemberName</code>) that allow you to obtain information about the caller of a method, which is particularly useful for diagnostic purposes.</p> <p>C# 5.0 <pre><code>public void LogMessage(string message,\n[CallerMemberName] string memberName = \"\",\n[CallerFilePath] string filePath = \"\",\n[CallerLineNumber] int lineNumber = 0)\n{\nConsole.WriteLine($\"{filePath}({lineNumber}) {memberName}: {message}\");\n}\n</code></pre> This method logs a message along with information about the caller, without the caller needing to supply this information explicitly.</p> <p>C# &lt; 5.0 In earlier versions, obtaining caller information required manual input, such as passing the file name, line number, and member name as parameters, making logging and diagnostics more tedious and error-prone.</p> <pre><code>public void LogMessage(string message, string memberName, string filePath, int lineNumber)\n{\nConsole.WriteLine($\"{filePath}({lineNumber}) {memberName}: {message}\");\n}\n// Usage (manual and prone to errors)\nLogMessage(\"An error occurred.\", nameof(MyMethod), \"MyFile.cs\", 42);\n</code></pre>","tags":["C#","csharp"]},{"location":"C%23/6.0/","title":"6.0","text":"<p>C# 6.0, released with .NET Framework 4.6 in July 2015, introduced several syntactic sugar features that made the language more concise and expressive. These features helped reduce boilerplate code and made certain patterns more readable. Here are some of the key features introduced in C# 6.0, along with examples and comparisons to earlier versions of C#:</p>","tags":["C#","csharp"]},{"location":"C%23/6.0/#1-string-interpolation","title":"1. String Interpolation","text":"<p>String interpolation allows you to embed expressions directly within string literals using the <code>$</code> character, making the creation of formatted strings more readable.</p> <p>C# 6.0 <pre><code>var name = \"Alice\";\nvar greeting = $\"Hello, {name}!\";\nConsole.WriteLine(greeting);  // Output: \"Hello, Alice!\"\n</code></pre></p> <p>C# &lt; 6.0 Previously, you had to use <code>string.Format</code>, concatenation, or other methods to compose strings, which was less readable. <pre><code>var name = \"Alice\";\nvar greeting = string.Format(\"Hello, {0}!\", name);\n// or\nvar greeting = \"Hello, \" + name + \"!\";\nConsole.WriteLine(greeting);\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/6.0/#2-null-conditional-operators-and","title":"2. Null-conditional Operators (<code>?.</code> and <code>?[]</code>)","text":"<p>Null-conditional operators allow you to safely access members and elements of an object that might be <code>null</code>, reducing the amount of code needed for null checks.</p> <p>C# 6.0 <pre><code>string[] array = null;\nvar length = array?.Length;  // No NullReferenceException, 'length' will be null\nConsole.WriteLine(length);  // Output: \"\"\n</code></pre></p> <p>C# &lt; 6.0 Before C# 6.0, you had to explicitly check for <code>null</code> to avoid <code>NullReferenceException</code>. <pre><code>string[] array = null;\nvar length = (array != null) ? array.Length : (int?)null;\nConsole.WriteLine(length);\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/6.0/#3-expression-bodied-members","title":"3. Expression-bodied Members","text":"<p>Expression-bodied members allow properties, methods, and read-only properties to have their bodies defined as an expression, making the syntax more concise for simple implementations.</p> <p>C# 6.0 <pre><code>public class Person\n{\npublic string FirstName { get; set; }\npublic string LastName { get; set; }\npublic string FullName =&gt; $\"{FirstName} {LastName}\";\n}\n</code></pre></p> <p>C# &lt; 6.0 Previously, even simple properties or methods required a full body with a <code>return</code> statement. <pre><code>public class Person\n{\npublic string FirstName { get; set; }\npublic string LastName { get; set; }\npublic string FullName\n{\nget { return FirstName + \" \" + LastName; }\n}\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/6.0/#4-auto-property-initializers","title":"4. Auto-property Initializers","text":"<p>Auto-property initializers allow you to directly initialize auto-implemented properties at their declaration point, simplifying the initialization of properties.</p> <p>C# 6.0 <pre><code>public class Person\n{\npublic string Name { get; set; } = \"Unknown\";\n}\n</code></pre></p> <p>C# &lt; 6.0 Before C# 6.0, property initialization required a constructor or field initialization. <pre><code>public class Person\n{\npublic string Name { get; set; }\npublic Person()\n{\nName = \"Unknown\";\n}\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/6.0/#5-nameof-expressions","title":"5. Nameof Expressions","text":"<p>The <code>nameof</code> operator provides a safe way to obtain the name of a variable, type, or member as a string, making your code more refactor-safe.</p> <p>C# 6.0 <pre><code>public void NotifyPropertyChanged(string propertyName)\n{\nConsole.WriteLine($\"Property changed: {propertyName}\");\n}\nNotifyPropertyChanged(nameof(Name));\n</code></pre></p> <p>C# &lt; 6.0 Previously, you had to use string literals, which could lead to errors during refactoring. <pre><code>public void NotifyPropertyChanged(string propertyName)\n{\nConsole.WriteLine($\"Property changed: {propertyName}\");\n}\nNotifyPropertyChanged(\"Name\");\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/7.0/","title":"7.0","text":"<p>C# 7.0, released with Visual Studio 2017 and .NET Framework 4.7, introduced several new features aimed at improving code clarity and reducing common coding patterns' complexity. Here are some of the key features introduced in C# 7.0, along with examples and comparisons to earlier versions of C#:</p>","tags":["C#","csharp"]},{"location":"C%23/7.0/#1-tuples-and-deconstruction","title":"1. Tuples and Deconstruction","text":"<p>C# 7.0 introduced built-in support for tuples, allowing you to return multiple values from a method without creating a custom class or struct. It also introduced deconstruction, enabling you to decompose a tuple into separate variables.</p> <p>C# 7.0 <pre><code>public (string, int) GetNameAndAge() =&gt; (\"Alice\", 30);\nvar (name, age) = GetNameAndAge();\nConsole.WriteLine($\"Name: {name}, Age: {age}\");\n</code></pre></p> <p>C# &lt; 7.0 Before C# 7.0, you would typically use <code>out</code> parameters or define a custom class or struct to return multiple values from a method. <pre><code>public void GetNameAndAge(out string name, out int age)\n{\nname = \"Alice\";\nage = 30;\n}\nstring name;\nint age;\nGetNameAndAge(out name, out age);\nConsole.WriteLine($\"Name: {name}, Age: {age}\");\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/7.0/#2-pattern-matching","title":"2. Pattern Matching","text":"<p>Pattern matching in C# 7.0 introduced more expressive ways to handle type checking and casting, particularly useful within <code>switch</code> statements or <code>is</code> expressions.</p> <p>C# 7.0 <pre><code>object obj = 42;\nif (obj is int number)\n{\nConsole.WriteLine($\"Integer: {number}\");\n}\n</code></pre></p> <p>C# &lt; 7.0 Previously, type checking and casting were more verbose and less intuitive. <pre><code>object obj = 42;\nif (obj is int)\n{\nint number = (int)obj;\nConsole.WriteLine($\"Integer: {number}\");\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/7.0/#3-local-functions","title":"3. Local Functions","text":"<p>C# 7.0 allows you to define functions within the scope of another method, enhancing encapsulation and readability for helper functions that are only relevant within a single method.</p> <p>C# 7.0 <pre><code>public int Add(int x, int y)\n{\nreturn AddInternal(x, y);\nint AddInternal(int a, int b) =&gt; a + b;\n}\n</code></pre></p> <p>C# &lt; 7.0 In earlier versions, you would typically use private methods or lambda expressions for similar functionality, which could clutter the class's API or be less efficient. <pre><code>public int Add(int x, int y)\n{\nFunc&lt;int, int, int&gt; addInternal = (a, b) =&gt; a + b;\nreturn addInternal(x, y);\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/7.0/#4-out-variables","title":"4. Out Variables","text":"<p>C# 7.0 introduced the ability to declare <code>out</code> variables inline, simplifying methods that return values via <code>out</code> parameters.</p> <p>C# 7.0 <pre><code>if (int.TryParse(\"123\", out int result))\n{\nConsole.WriteLine(result);  // Output: 123\n}\n</code></pre></p> <p>C# &lt; 7.0 Previously, you needed to declare <code>out</code> variables before the method call. <pre><code>int result;\nif (int.TryParse(\"123\", out result))\n{\nConsole.WriteLine(result);\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/7.0/#5-ref-returns-and-locals","title":"5. Ref Returns and Locals","text":"<p>C# 7.0 introduced ref returns and locals, allowing methods to return references to variables, rather than values, which can improve performance for certain scenarios.</p> <p>C# 7.0 <pre><code>public ref int Find(int[] numbers, int target)\n{\nfor (int i = 0; i &lt; numbers.Length; i++)\n{\nif (numbers[i] == target)\n{\nreturn ref numbers[i];  // Return a reference to the found element\n}\n}\nthrow new IndexOutOfRangeException(\"Not found\");\n}\nint[] array = { 1, 2, 3 };\nref int refToTwo = ref Find(array, 2);\nrefToTwo = 4;  // Updates the array element directly\nConsole.WriteLine(array[1]);  // Output: 4\n</code></pre></p> <p>C# &lt; 7.0 Before C# 7.0, methods could only return values, not references. Changing a value in an array or a large structure required returning the entire updated structure or modifying it via an <code>out</code> or <code>ref</code> parameter.</p>","tags":["C#","csharp"]},{"location":"C%23/8.0/","title":"8.0","text":"<p>C# 8.0, released with .NET Core 3.0 in September 2019, introduced several significant features that aimed to improve code safety, readability, and reduce boilerplate code. Here are some of the key features introduced in C# 8.0, along with examples and comparisons to earlier versions of C#:</p>","tags":["C#","csharp"]},{"location":"C%23/8.0/#1-nullable-reference-types","title":"1. Nullable Reference Types","text":"<p>C# 8.0 introduced nullable reference types to help developers avoid null reference exceptions. This feature allows the compiler to provide warnings when code might dereference <code>null</code>.</p> <p>C# 8.0 <pre><code>#nullable enable\nstring? nullableString = null;\nstring nonNullableString = nullableString; // Warning: Converting null literal or possible null value to non-nullable type.\n</code></pre></p> <p>C# &lt; 8.0 In previous versions, reference types could always hold null, but the compiler didn't provide warnings for potential null dereference. <pre><code>string nullableString = null;\nstring nonNullableString = nullableString; // No warning, but could result in a runtime null reference exception.\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/8.0/#2-default-interface-methods","title":"2. Default Interface Methods","text":"<p>C# 8.0 allows interfaces to define default implementations for members. This lets you add new methods to an interface without breaking existing implementations.</p> <p>C# 8.0 <pre><code>interface ILogger\n{\nvoid Log(string message);\nvoid LogWarning(string message) =&gt; Log($\"Warning: {message}\");\n}\n</code></pre></p> <p>C# &lt; 8.0 Previously, adding a new method to an interface required implementing the method in all classes that implement the interface, potentially breaking existing code. <pre><code>interface ILogger\n{\nvoid Log(string message);\n// Adding a new method here would require changes to all implementing classes.\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/8.0/#3-pattern-matching-enhancements","title":"3. Pattern Matching Enhancements","text":"<p>C# 8.0 expanded pattern matching capabilities, including switch expressions, property patterns, tuple patterns, and positional patterns.</p> <p>C# 8.0 <pre><code>public string GetQuadrant(Point point) =&gt; point switch\n{\n{ X: 0, Y: 0 } =&gt; \"Origin\",\n{ X: &gt; 0, Y: &gt; 0 } =&gt; \"Quadrant 1\",\n_ =&gt; \"Other\"\n};\n</code></pre></p> <p>C# &lt; 8.0 Pattern matching existed before C# 8.0 but was less flexible. For instance, <code>switch</code> statements were more verbose and didn't support deconstructing types or property patterns. <pre><code>public string GetQuadrant(Point point)\n{\nswitch (point)\n{\ncase Point var p when p.X &gt; 0 &amp;&amp; p.Y &gt; 0:\nreturn \"Quadrant 1\";\ncase Point var p when p.X == 0 &amp;&amp; p.Y == 0:\nreturn \"Origin\";\ndefault:\nreturn \"Other\";\n}\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/8.0/#4-async-streams","title":"4. Async Streams","text":"<p>C# 8.0 introduced the <code>IAsyncEnumerable&lt;T&gt;</code> interface and <code>await foreach</code> syntax to support asynchronous streams, which are useful for processing sequences of data asynchronously.</p> <p>C# 8.0 <pre><code>public async IAsyncEnumerable&lt;int&gt; GetNumbersAsync()\n{\nfor (int i = 0; i &lt; 3; i++)\n{\nawait Task.Delay(100); // Simulate async work\nyield return i;\n}\n}\nawait foreach (var number in GetNumbersAsync())\n{\nConsole.WriteLine(number);\n}\n</code></pre></p> <p>C# &lt; 8.0 Asynchronous processing of streams required more cumbersome approaches, such as using <code>Task&lt;IEnumerable&lt;T&gt;&gt;</code> which doesn't allow for streaming of data as it's produced. <pre><code>public async Task&lt;IEnumerable&lt;int&gt;&gt; GetNumbersAsync()\n{\nList&lt;int&gt; numbers = new List&lt;int&gt;();\nfor (int i = 0; i &lt; 3; i++)\n{\nawait Task.Delay(100); // Simulate async work\nnumbers.Add(i);\n}\nreturn numbers;\n}\nvar numbers = await GetNumbersAsync();\nforeach (var number in numbers)\n{\nConsole.WriteLine(number);\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/8.0/#5-using-declarations","title":"5. Using Declarations","text":"<p>C# 8.0 introduced using declarations, a more concise way to ensure that IDisposable objects are properly disposed of, reducing the need for boilerplate <code>using</code> blocks.</p> <p>C# 8.0 <pre><code>using var file = new StreamWriter(\"file.txt\");\nfile.WriteLine(\"Hello, C# 8.0!\");\n// The StreamWriter is automatically disposed at the end of the scope.\n</code></pre></p> <p>C# &lt; 8.0 Previously, <code>using</code> statements required more verbose block syntax. <pre><code>using (var file = new StreamWriter(\"file.txt\"))\n{\nfile.WriteLine(\"Hello, C#!\");\n// Exiting the using block disposes the StreamWriter.\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/9.0/","title":"9.0","text":"<p>C# 9.0, released with .NET 5 in November 2020, introduced several new features aimed at making the language more concise, expressive, and efficient for modern development practices. Here are some of the key features introduced in C# 9.0, along with examples and comparisons to earlier versions of C#:</p>","tags":["C#","csharp"]},{"location":"C%23/9.0/#1-records","title":"1. Records","text":"<p>Records are a reference type that provides built-in functionality for encapsulating immutable data. They are ideal for scenarios where the primary purpose of the type is to store data with little to no behavior.</p> <p>C# 9.0 <pre><code>public record Person(string FirstName, string LastName);\n</code></pre></p> <p>C# &lt; 9.0 Before C# 9.0, creating an immutable class required more boilerplate code, including manually implementing value equality. <pre><code>public class Person\n{\npublic string FirstName { get; }\npublic string LastName { get; }\npublic Person(string firstName, string lastName) =&gt; (FirstName, LastName) = (firstName, lastName);\nprotected bool Equals(Person other) =&gt; FirstName == other.FirstName &amp;&amp; LastName == other.LastName;\npublic override bool Equals(object obj)\n{\nif (ReferenceEquals(null, obj)) return false;\nif (ReferenceEquals(this, obj)) return true;\nif (obj.GetType() != this.GetType()) return false;\nreturn Equals((Person)obj);\n}\npublic override int GetHashCode() =&gt; HashCode.Combine(FirstName, LastName);\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/9.0/#2-init-only-setters","title":"2. Init Only Setters","text":"<p>Init only setters provide a way to make individual properties immutable after object construction, enhancing the support for immutable data types in C#.</p> <p>C# 9.0 <pre><code>public class Person\n{\npublic string FirstName { get; init; }\npublic string LastName { get; init; }\n}\nvar person = new Person { FirstName = \"John\", LastName = \"Doe\" };\n// person.FirstName = \"Jane\"; // Error: Init-only property or indexer 'Person.FirstName' can only be assigned in an object initializer\n</code></pre></p> <p>C# &lt; 9.0 Previously, to achieve immutability for individual properties, you had to use readonly fields or properties with private setters, which could only be set in the constructor. <pre><code>public class Person\n{\npublic string FirstName { get; private set; }\npublic string LastName { get; private set; }\npublic Person(string firstName, string lastName)\n{\nFirstName = firstName;\nLastName = lastName;\n}\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/9.0/#3-top-level-statements","title":"3. Top-level Statements","text":"<p>Top-level statements reduce the boilerplate code required for simple programs, allowing you to write the main body of a program without the need for a <code>Main</code> method.</p> <p>C# 9.0 <pre><code>Console.WriteLine(\"Hello, World!\");\n</code></pre></p> <p>C# &lt; 9.0 In earlier versions, a <code>Main</code> method was required as an entry point for every console application. <pre><code>class Program\n{\nstatic void Main(string[] args)\n{\nConsole.WriteLine(\"Hello, World!\");\n}\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/9.0/#4-pattern-matching-enhancements","title":"4. Pattern Matching Enhancements","text":"<p>C# 9.0 introduced new pattern matching capabilities, such as simple type patterns, relational patterns, and logical patterns, making pattern matching more expressive and powerful.</p> <p>C# 9.0 <pre><code>public static string GetDescription(object obj) =&gt; obj switch\n{\n&gt; 0 and &lt; 10 =&gt; \"Between 0 and 10\",\nstring s =&gt; $\"String of length {s.Length}\",\nnull =&gt; \"Null\",\n_ =&gt; \"Unknown\"\n};\n</code></pre></p> <p>C# &lt; 9.0 Pattern matching was less expressive, and certain patterns required more verbose code or were not possible. <pre><code>public static string GetDescription(object obj)\n{\nif (obj is int i &amp;&amp; i &gt; 0 &amp;&amp; i &lt; 10)\n{\nreturn \"Between 0 and 10\";\n}\nelse if (obj is string s)\n{\nreturn $\"String of length {s.Length}\";\n}\nelse if (obj == null)\n{\nreturn \"Null\";\n}\nelse\n{\nreturn \"Unknown\";\n}\n}\n</code></pre></p>","tags":["C#","csharp"]},{"location":"C%23/9.0/#5-target-typed-new-expressions","title":"5. Target-typed <code>new</code> Expressions","text":"<p>C# 9.0 allows the type of the <code>new</code> expression to be inferred from the context, reducing redundancy when the type is already known.</p> <p>C# 9.0 <pre><code>Person person = new(\"John\", \"Doe\");\n</code></pre></p> <p>C# &lt; 9.0 Previously, you had to specify the type explicitly for each <code>new</code> expression. <pre><code>Person person = new Person(\"John\", \"Doe\");\n</code></pre></p>","tags":["C#","csharp"]}]}